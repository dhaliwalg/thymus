#!/usr/bin/env bash
set -euo pipefail

# Thymus generate-agents-md.sh
# Generates an architectural rules markdown section from invariants.yml
# and project scan results, suitable for AGENTS.md or CLAUDE.md.
#
# Usage: bash generate-agents-md.sh [project_root]
# Output: Markdown to stdout
#
# Input files (all under project_root/.thymus/):
#   - invariants.yml       (required)
#   - baseline.json        (optional — enhances output)
#
# Also runs detect-patterns.sh and scan-dependencies.sh for live data.

PROJECT_ROOT="${1:-$PWD}"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DEBUG_LOG="/tmp/thymus-debug.log"
TIMESTAMP=$(date '+%Y-%m-%dT%H:%M:%S')
GENERATED_AT=$(date '+%Y-%m-%d %H:%M:%S')

echo "[$TIMESTAMP] generate-agents-md.sh running for $PROJECT_ROOT" >> "$DEBUG_LOG"

INVARIANTS_FILE="$PROJECT_ROOT/.thymus/invariants.yml"
BASELINE_FILE="$PROJECT_ROOT/.thymus/baseline.json"

if [ ! -f "$INVARIANTS_FILE" ]; then
  echo "Error: $INVARIANTS_FILE not found. Run /thymus:baseline first." >&2
  exit 1
fi

# ---- Gather data ----

# Run dependency scan for language/framework
DEPS_JSON=$(bash "$SCRIPT_DIR/scan-dependencies.sh" "$PROJECT_ROOT" 2>/dev/null || echo '{"language":"unknown","framework":"unknown"}')
LANGUAGE=$(echo "$DEPS_JSON" | jq -r '.language // "unknown"')
FRAMEWORK=$(echo "$DEPS_JSON" | jq -r '.framework // "unknown"')

# Run pattern scan for layers
PATTERNS_JSON=$(bash "$SCRIPT_DIR/detect-patterns.sh" "$PROJECT_ROOT" 2>/dev/null || echo '{"detected_layers":[],"raw_structure":[]}')
DETECTED_LAYERS=$(echo "$PATTERNS_JSON" | jq -r '.detected_layers[]' 2>/dev/null || true)

# Parse invariants to JSON using the same Python parser pattern
CACHE_DIR="/tmp/thymus-agentsmd-$$"
mkdir -p "$CACHE_DIR"

python3 - "$INVARIANTS_FILE" "$CACHE_DIR/invariants.json" <<'PYEOF'
import json, re, sys

src = sys.argv[1]
dst = sys.argv[2]

def parse(src, dst):
    with open(src) as f:
        lines = f.readlines()
    invariants = []
    current = None
    list_key = None
    for line in lines:
        raw = line.rstrip('\n')
        stripped = raw.strip()
        if stripped.startswith('#') or stripped == '' or stripped.startswith('version:'):
            continue
        if stripped == 'invariants:':
            continue
        indent = len(raw) - len(raw.lstrip())
        if stripped.startswith('- id:'):
            if current:
                invariants.append(current)
            current = {'id': stripped.split(':', 1)[1].strip().strip('"').strip("'")}
            list_key = None
        elif current and indent >= 4 and ':' in stripped and not stripped.startswith('- '):
            list_key = None
            key, val = stripped.split(':', 1)
            key = key.strip()
            val = val.strip().strip('"').strip("'")
            if val == '' or val == '[]':
                list_key = key
                current[key] = []
            elif val.startswith('[') and val.endswith(']'):
                items = [x.strip().strip('"').strip("'") for x in val[1:-1].split(',')]
                current[key] = [x for x in items if x]
            else:
                current[key] = val
        elif current and list_key and stripped.startswith('- '):
            item = stripped[2:].strip().strip('"').strip("'")
            current[list_key].append(item)
    if current:
        invariants.append(current)
    with open(dst, 'w') as f:
        json.dump(invariants, f)

parse(src, dst)
PYEOF

INVARIANTS_JSON="$CACHE_DIR/invariants.json"
if [ ! -f "$INVARIANTS_JSON" ]; then
  echo "Error: Failed to parse invariants.yml" >&2
  rm -rf "$CACHE_DIR"
  exit 1
fi

# ---- Helper: map directory names to roles ----
_layer_role() {
  case "$1" in
    routes|router|routing) echo "HTTP route definitions" ;;
    controllers|controller) echo "HTTP request handlers" ;;
    services|service) echo "Business logic" ;;
    repositories|repository|repo|repos) echo "Data access" ;;
    models|model|entities|entity) echo "Data structures" ;;
    middleware) echo "Request/response middleware" ;;
    utils|util|helpers|lib) echo "Shared utilities" ;;
    handlers|handler) echo "Request handlers" ;;
    types|dto) echo "Type definitions and data transfer objects" ;;
    db|database) echo "Database layer" ;;
    config) echo "Configuration" ;;
    auth) echo "Authentication and authorization" ;;
    tests|test|__tests__|spec) echo "Test files" ;;
    components) echo "UI components" ;;
    pages|views) echo "Page/view templates" ;;
    domain) echo "Domain logic" ;;
    infrastructure|adapter) echo "Infrastructure adapters" ;;
    *) echo "" ;;
  esac
}

# ---- Generate markdown ----

# Header
cat << 'HEADER'
<!-- Generated by Thymus. Regenerate with: /thymus:agents-md -->
HEADER
echo "<!-- Last generated: $GENERATED_AT -->"
echo ""

# Section 1: Architecture Overview
echo "## Architecture Rules (managed by Thymus)"
echo ""

LANG_DISPLAY="$LANGUAGE"
if [ "$FRAMEWORK" != "unknown" ]; then
  LANG_DISPLAY="$LANGUAGE/$FRAMEWORK"
fi

echo "This project is a **${LANG_DISPLAY}** application with the following layer structure:"
echo ""

# List detected layers with roles
if [ -n "$DETECTED_LAYERS" ]; then
  echo "$DETECTED_LAYERS" | while read -r layer; do
    role=$(_layer_role "$layer")
    if [ -n "$role" ]; then
      # Find actual path for this layer
      layer_path=$(echo "$PATTERNS_JSON" | jq -r --arg l "$layer" '.raw_structure[] | select(endswith("/" + $l) or . == $l)' 2>/dev/null | head -1)
      if [ -n "$layer_path" ]; then
        echo "- \`${layer_path}/\` — $role"
      else
        echo "- \`${layer}/\` — $role"
      fi
    fi
  done
fi
echo ""

# Section 2: Hard Boundary Rules
BOUNDARY_COUNT=$(jq '[.[] | select(.type == "boundary")] | length' "$INVARIANTS_JSON")
if [ "$BOUNDARY_COUNT" -gt 0 ]; then
  echo "### Import Boundaries (STRICT — CI will reject violations)"
  echo ""

  jq -c '.[] | select(.type == "boundary")' "$INVARIANTS_JSON" | while read -r rule; do
    rule_id=$(echo "$rule" | jq -r '.id')
    desc=$(echo "$rule" | jq -r '.description // ""')
    source_glob=$(echo "$rule" | jq -r '.source_glob // ""')
    forbidden=$(echo "$rule" | jq -r '.forbidden_imports // [] | join(", ")' 2>/dev/null || true)
    reasoning=$(echo "$rule" | jq -r '.reasoning // ""')

    if [ -n "$source_glob" ] && [ -n "$forbidden" ]; then
      echo -n "- Files in \`$source_glob\` **MUST NOT** import from \`$forbidden\`."
      if [ -n "$reasoning" ] && [ "$reasoning" != "null" ]; then
        echo " $reasoning"
      else
        echo " ($desc)"
      fi
    else
      echo "- **$rule_id**: $desc"
    fi
  done
  echo ""
fi

# Pattern rules
PATTERN_COUNT=$(jq '[.[] | select(.type == "pattern")] | length' "$INVARIANTS_JSON")
if [ "$PATTERN_COUNT" -gt 0 ]; then
  echo "### Pattern Restrictions"
  echo ""

  jq -c '.[] | select(.type == "pattern")' "$INVARIANTS_JSON" | while read -r rule; do
    desc=$(echo "$rule" | jq -r '.description // ""')
    scope_glob=$(echo "$rule" | jq -r '.scope_glob // ""')
    forbidden_pattern=$(echo "$rule" | jq -r '.forbidden_pattern // ""')

    if [ -n "$scope_glob" ] && [ -n "$forbidden_pattern" ]; then
      echo "- In \`$scope_glob\`: $desc"
    else
      echo "- $desc"
    fi
  done
  echo ""
fi

# Dependency rules
DEP_COUNT=$(jq '[.[] | select(.type == "dependency")] | length' "$INVARIANTS_JSON")
if [ "$DEP_COUNT" -gt 0 ]; then
  echo "### Dependency Restrictions"
  echo ""

  jq -c '.[] | select(.type == "dependency")' "$INVARIANTS_JSON" | while read -r rule; do
    desc=$(echo "$rule" | jq -r '.description // ""')
    package=$(echo "$rule" | jq -r '.package // ""')
    allowed_in=$(echo "$rule" | jq -r '.allowed_in // [] | join(", ")' 2>/dev/null || true)

    if [ -n "$package" ] && [ -n "$allowed_in" ]; then
      echo "- The \`$package\` package may ONLY be imported in \`$allowed_in\`. $desc"
    else
      echo "- $desc"
    fi
  done
  echo ""
fi

# Convention rules
CONV_COUNT=$(jq '[.[] | select(.type == "convention")] | length' "$INVARIANTS_JSON")
if [ "$CONV_COUNT" -gt 0 ]; then
  echo "### Conventions"
  echo ""

  jq -c '.[] | select(.type == "convention")' "$INVARIANTS_JSON" | while read -r rule; do
    desc=$(echo "$rule" | jq -r '.description // ""')
    rule_text=$(echo "$rule" | jq -r '.rule // ""')

    echo -n "- $desc"
    if [ -n "$rule_text" ] && [ "$rule_text" != "null" ]; then
      echo " ($rule_text)"
    else
      echo ""
    fi
  done
  echo ""
fi

# Section 3: Semantic / Aspirational Rules (AI-only)
echo "### Architectural Guidelines (enforced by AI agents, not CI)"
echo ""

# Generate framework-specific semantic rules
case "$FRAMEWORK" in
  nextjs)
    echo "- **Server/client boundary**: Components using browser APIs must be marked with \`\"use client\"\`. Server components must not import client-only modules."
    echo "- **Data fetching**: Prefer server-side data fetching in page components. Avoid \`useEffect\` for initial data loads."
    ;;
  express|fastify)
    echo "- **Separation of concerns**: Route handlers should only parse requests and return responses. Business logic belongs in services."
    echo "- **Middleware ordering**: Auth middleware should run before route handlers. Error middleware should be registered last."
    ;;
  django)
    echo "- **Fat models, thin views**: Business logic belongs in model methods or service classes, not in views."
    echo "- **Use managers**: Complex querysets should be defined as manager methods, not inline in views."
    ;;
  fastapi)
    echo "- **Dependency injection**: Use \`Depends()\` for all service dependencies. Avoid direct instantiation in route functions."
    echo "- **Pydantic schemas**: Request/response models should be Pydantic BaseModel subclasses in a dedicated schemas module."
    ;;
  spring-boot|spring-mvc)
    echo "- **Constructor injection**: Use constructor injection over \`@Autowired\` field injection for better testability."
    echo "- **Transaction boundaries**: \`@Transactional\` belongs on service methods, not controllers."
    ;;
  gin|echo|fiber|chi)
    echo "- **Handler simplicity**: HTTP handlers should delegate to service functions. Keep handlers focused on request parsing and response formatting."
    echo "- **Context propagation**: Pass \`context.Context\` through the call chain. Don't create new contexts in service layers."
    ;;
  actix|axum|rocket)
    echo "- **Error handling**: Use \`Result\` types throughout. Convert to HTTP errors at the handler boundary, not in business logic."
    echo "- **Async safety**: Avoid blocking operations in async handlers. Use \`spawn_blocking\` for CPU-intensive work."
    ;;
  flutter)
    echo "- **State management**: Use the project's established state management pattern consistently. Don't mix approaches."
    echo "- **Widget composition**: Prefer composition over inheritance. Extract widgets when a build method exceeds ~50 lines."
    ;;
  ktor)
    echo "- **Coroutine safety**: Use structured concurrency. Don't launch unscoped coroutines in route handlers."
    echo "- **Configuration**: Use Ktor's application.conf for settings, not hardcoded values."
    ;;
  vapor)
    echo "- **Fluent models**: Keep database model definitions separate from business logic. Use migrations for schema changes."
    echo "- **Async patterns**: Use async/await consistently. Avoid callback-style code."
    ;;
  laravel)
    echo "- **Eloquent discipline**: Use Eloquent scopes and relationships. Avoid raw SQL outside repository classes."
    echo "- **Form requests**: Use Form Request classes for validation, not inline validation in controllers."
    ;;
  rails)
    echo "- **Skinny controllers**: Controllers should delegate to models or service objects. Keep actions under 10 lines."
    echo "- **Convention over configuration**: Follow Rails naming conventions. Don't fight the framework."
    ;;
  aspnet)
    echo "- **Dependency injection**: Register services in Program.cs/Startup.cs. Use constructor injection throughout."
    echo "- **Async all the way**: Use async/await consistently. Don't mix sync and async I/O operations."
    ;;
  *)
    ;;
esac

# Universal semantic rules
echo "- **New dependencies**: Before adding a new package dependency, check if existing utilities cover the use case. Prefer the project's established patterns."

# Check for error handling patterns
if echo "$DETECTED_LAYERS" | grep -qi "error\|exception"; then
  echo "- **Error handling**: Use the project's error handling pattern. Don't catch and swallow errors silently. Don't return raw database errors to clients."
fi

# Test pattern advice
if echo "$DETECTED_LAYERS" | grep -qi "test"; then
  echo "- **Test patterns**: Follow the existing test structure. Mock external services, don't mock internal modules."
fi

echo ""

# Cleanup
rm -rf "$CACHE_DIR"
